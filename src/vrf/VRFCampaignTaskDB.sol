//SPDX-License-Identifier:MIT
pragma solidity >=0.8.8;

import "./VRFCircleProblem.sol";


error ErrVRF_CannotEnableCampaigns();

error ErrVRF_CampaignWithoutBounty();


struct VRFCampaignTask
{
    uint256 campaingID;
    /**
    * The client task ID which is notified when a new random number is generated.
    * This number could mean a target Island which needs a random seed for ring generation,
    * Or also it could tell the random seed for a Propomtion Lottery.
    */
    uint256 task_refID;
    /**
    * IF bounty is 0, then this problem has already solved
    */
    uint256 bounty;

    /// Generated random seed
    uint256 random_seed;

    uint256 winner_record;
}

interface IVRFCampaignTaskDB is IERC165
{
    /// Campaign information
    function campaign_count() external view returns (uint256);
    function campaign_rnd_result(uint256 campaignID) external view returns (uint256);
    function campaign_task(uint256 campaignID) external view returns (uint256);
    function campaign_winner(uint256 campaignID) external view returns (uint256);
    function is_campaign_finished(uint256 campaignID) external view returns (bool);
    function campaign_bounty(uint256 campaignID) external view returns (uint256);    
    function fetch_campaign_info(uint256 campaignID) external view returns (VRFCampaignTask memory);

    /// Campaign operations

    /**
     * Inserts a new campaign and raises an event.
     */
    function insert_task(uint256 task_refID, uint256 bounty) external returns (uint256);

    /**
     * This method assigns the resulting random seed generated by FREE_RANDAO, and announces the winner of 
     * the campaign.
     * This method raises an event.
     * Returns the bounty of the campaign, and then sets it to 0.
     */
    function finalize_campaign(uint256 finished_campaignID, uint256 random_seed, uint256 winner_record) external returns(uint256);
}

contract VRFCampaignTaskDB is IVRFCampaignTaskDB, ERC165, FREE_Controllable 
{
    modifier onlyClient() {
        _checkOwner();
        _;
    }

    /**
    * A one-based Array set which matchs the campaign ID with the task information
    */
    mapping(uint256 => VRFCampaignTask) private _campaign_tasks;

    /**
    * This value is always incrementing. Each time tells the newly created campaign when a task is inserted  
    */
       uint256 private _campaing_count;

    constructor(address initialOwner) FREE_Controllable(initialOwner)
    {
        _campaing_count = 0;
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return interfaceId == type(IVRFCampaignTaskDB).interfaceId || super.supportsInterface(interfaceId);
    }
    
    function campaign_count() external view virtual override returns (uint256)
    {
        return _campaing_count;
    }

    function campaign_rnd_result(uint256 campaignID) external view virtual override returns (uint256)
    {
        VRFCampaignTask storage campaignobj = _campaign_tasks[campaignID];
        return campaignobj.random_seed;
    }

    function campaign_task(uint256 campaignID) external view virtual override returns(uint256)
    {
        VRFCampaignTask storage campaignobj = _campaign_tasks[campaignID];
        return campaignobj.task_refID;
    }

    function campaign_winner(uint256 campaignID) external view virtual override returns(uint256)
    {
        VRFCampaignTask storage campaignobj = _campaign_tasks[campaignID];
        return campaignobj.winner_record;
    }

    function is_campaign_finished(uint256 campaignID) external view virtual override returns(bool)
    {
        VRFCampaignTask storage campaignobj = _campaign_tasks[campaignID];
        return campaignobj.bounty == uint256(0);
    }

    function campaign_bounty(uint256 campaignID) external view returns (uint256)
    {
        VRFCampaignTask storage campaignobj = _campaign_tasks[campaignID];
        return campaignobj.bounty;
    }

    function fetch_campaign_info(uint256 campaignID) external view returns (VRFCampaignTask memory)
    {
        return _campaign_tasks[campaignID];
    }

    /// Campaign operations

    /**
     * Inserts a new campaign and raises an event.
     */
    function insert_task(uint256 task_refID, uint256 bounty) external virtual override onlyClient returns (uint256)
    {		
        uint256 new_campaignID = _campaing_count + 1;
        _campaing_count = new_campaignID;

        _campaign_tasks[new_campaignID].campaingID = new_campaignID;
        _campaign_tasks[new_campaignID].task_refID = task_refID;
        _campaign_tasks[new_campaignID].bounty = bounty;
        
        return new_campaignID;
    }

    /**
     * This method assigns the resulting random seed generated by FREE_RANDAO, and announces the winner of 
     * the campaign.
     * This method raises an event.
     */
    function finalize_campaign(uint256 finished_campaignID, uint256 random_seed, uint256 winner_record) 
    external virtual override onlyClient returns(uint256)
    {
        VRFCampaignTask storage _finished_campaign = _campaign_tasks[finished_campaignID];

        uint256 ret_bounty = _finished_campaign.bounty;
        _finished_campaign.bounty = uint256(0);// clear bounty
        _finished_campaign.random_seed = random_seed;
        _finished_campaign.winner_record = winner_record;

        return ret_bounty;
    }
}

